# Redis实现skipList(跳表)

## 项目介绍
跳表是非关系型数据库（如Redis、LevelDB、RocksDB）核心存储引擎的关键数据结构。本项目旨在使用C++实现一个基于跳表的轻量级键值型存储引擎。主要功能包括插入数据、删除数据、查询数据、数据展示、数据持久化（落盘）、从文件加载数据，以及显示数据库大小。

深入: [Redis设计与实现](https://redisbook.readthedocs.io/en/latest/index.html)

## 接口函数
- `int insert_element(K, V);` - 插入数据
- `void display_list();` - 展示跳表中的数据
- `bool search_element(K);` - 搜索数据
- `void delete_element(K);` - 删除数据
- `void dump_file();` - 数据持久化到文件
- `void load_file();` - 从文件加载数据
- `int size();` - 返回存储的元素数量

## 跳表原理解释
### 什么是跳表
跳表是在单链表基础上进行的一种数据结构优化，能够将插入、删除、查找操作的时间复杂度都降低到O(log N)。跳表通过多层索引来实现快速操作，每一层都是原始链表的一个“简化版”，包含较少的元素。

![跳表](https://redisbook.readthedocs.io/en/latest/_images/skiplist.png)

### 查找操作的示例
例如，当查找元素8时，我们从最高层索引开始搜索，逐层向下，直到找到目标元素。与单链表相比，跳表能够更快地定位元素，特别是在包含大量元素的情况下。

### 插入、删除和查找的时间复杂度
跳表中的插入、删除和查找操作都利用索引来加速过程，这三种操作的时间复杂度几乎相同。例如，对于16个元素的单链表，跳表的索引层数和数量可以是：
- 0级（原始链表）索引数量: 16
- 1级索引数量: 8
- 2级索引数量: 4
- 3级索引数量: 2
这表明索引数量按层数以对数方式递减。

### 空间复杂度分析
虽然跳表的时间复杂度为O(log N)，但它通过增加空间复杂度（O(N)）来换取时间效率，因为索引数量随层数成等比递减。

### 索引更新

### 跳表索引更新的重要性
跳表的效率大部分来自于它的多层索引结构。如果在插入新元素时不适当地更新索引，跳表可能会逐渐失去其高效性，最终退化成普通的单链表。这种情况下，跳表的所有操作（查找、插入、删除）的效率都会显著降低。

### 如何进行索引更新
在跳表中插入新元素时，需要决定这个新元素应该被添加到哪些索引层中。这通常是通过一个随机过程实现的，以确保跳表的平衡和效率。以下是一个常见的做法：

1. **基础层添加：** 首先，每个新元素都会被添加到最底层的链表中（即原始链表）。

2. **随机层级选择：** 接着，使用一个随机函数来决定这个新元素应该上升到哪个索引层。例如，可以设定每个元素有50%的概率上升到下一个层级。

3. **逐层上升：** 如果随机函数确定元素应该上升到下一个层级，就继续进行判断，直到随机函数决定停止。这意味着一些元素可能只出现在基础层，而一些可能上升到更高的层级。

4. **维持平衡：** 这种随机上升的策略有助于维护跳表的平衡。理想情况下，每上升一层，跳表中的元素数量就减少一半，从而保持了操作的对数时间复杂度。

### 索引更新的效果
通过这种方式，跳表在插入新元素时动态更新索引。这确保了无论数据如何变化，跳表都能维持其高效的操作性能。同时，这种随机化过程也避免了需要额外复杂的算法来决定元素的层级，从而使得跳表结构简单而高效。
